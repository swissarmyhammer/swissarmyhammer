//! Shared build utilities for SwissArmyHammer crates.
//!
//! This crate provides common functionality for build.rs scripts that need to
//! embed builtin files (prompts, rules, workflows, validators, etc.) into the
//! binary at compile time.
//!
//! # Example
//!
//! ```no_run
//! // In build.rs:
//! use swissarmyhammer_build::BuiltinGenerator;
//!
//! fn main() {
//!     BuiltinGenerator::new("validators")
//!         .source_dir("../builtin/validators")
//!         .extensions(&["md"])
//!         .function_name("get_builtin_validators")
//!         .generate();
//! }
//! ```

use std::env;
use std::fmt::Write;
use std::fs;
use std::path::{Path, PathBuf};

/// Configuration for generating builtin embedding code.
pub struct BuiltinGenerator {
    /// Name of the resource type (for comments)
    resource_type: String,
    /// Source directory relative to manifest dir
    source_dir: String,
    /// Output file name (without .rs)
    output_name: String,
    /// Function name to generate
    function_name: String,
    /// File extensions to include
    extensions: Vec<String>,
    /// Directories to skip
    skip_dirs: Vec<String>,
}

impl BuiltinGenerator {
    /// Create a new generator for a resource type.
    ///
    /// # Arguments
    /// * `resource_type` - The type of resource (e.g., "prompts", "validators")
    pub fn new(resource_type: impl Into<String>) -> Self {
        let resource_type = resource_type.into();
        Self {
            output_name: format!("builtin_{}", resource_type),
            function_name: format!("get_builtin_{}", resource_type),
            source_dir: format!("../builtin/{}", resource_type),
            resource_type,
            extensions: vec!["md".to_string()],
            skip_dirs: vec![],
        }
    }

    /// Set the source directory relative to the crate's manifest directory.
    pub fn source_dir(mut self, dir: impl Into<String>) -> Self {
        self.source_dir = dir.into();
        self
    }

    /// Set the output file name (without .rs extension).
    pub fn output_name(mut self, name: impl Into<String>) -> Self {
        self.output_name = name.into();
        self
    }

    /// Set the function name to generate.
    pub fn function_name(mut self, name: impl Into<String>) -> Self {
        self.function_name = name.into();
        self
    }

    /// Set the file extensions to include (without leading dot).
    pub fn extensions(mut self, exts: &[&str]) -> Self {
        self.extensions = exts.iter().map(|s| s.to_string()).collect();
        self
    }

    /// Set directories to skip during collection.
    pub fn skip_dirs(mut self, dirs: &[&str]) -> Self {
        self.skip_dirs = dirs.iter().map(|s| s.to_string()).collect();
        self
    }

    /// Generate the builtin embedding code.
    ///
    /// This should be called from build.rs. It will:
    /// 1. Set up cargo rerun-if-changed directives
    /// 2. Generate Rust code that embeds all matching files
    /// 3. Write the code to OUT_DIR
    pub fn generate(&self) {
        let manifest_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
        let out_dir = env::var("OUT_DIR").unwrap();

        let builtin_dir = Path::new(&manifest_dir).join(&self.source_dir);

        // Tell Cargo to rerun if the source directory changes
        println!("cargo:rerun-if-changed={}", builtin_dir.display());

        let dest_path = Path::new(&out_dir).join(format!("{}.rs", self.output_name));

        let code = self.generate_code(&builtin_dir);
        fs::write(&dest_path, code).unwrap();
    }

    /// Generate the Rust code for embedding builtins.
    fn generate_code(&self, builtin_dir: &Path) -> String {
        let mut code = String::new();

        writeln!(
            code,
            "// Auto-generated builtin {} - do not edit manually",
            self.resource_type
        )
        .unwrap();
        writeln!(
            code,
            "// Generated by build.rs from {} directory\n",
            self.source_dir
        )
        .unwrap();

        writeln!(
            code,
            "/// Get all built-in {} as a vector of (name, content) tuples",
            self.resource_type
        )
        .unwrap();
        writeln!(
            code,
            "pub fn {}() -> Vec<(&'static str, &'static str)> {{",
            self.function_name
        )
        .unwrap();
        code.push_str("    vec![\n");

        if builtin_dir.exists() {
            self.collect_files(builtin_dir, "", &mut code);
        }

        code.push_str("    ]\n");
        code.push_str("}\n");

        code
    }

    /// Recursively collect files from a directory.
    fn collect_files(&self, dir: &Path, prefix: &str, code: &mut String) {
        let Ok(entries) = fs::read_dir(dir) else {
            return;
        };

        let mut entries: Vec<_> = entries.collect();
        entries.sort_by_key(|entry| entry.as_ref().unwrap().path());

        for entry in entries.into_iter().flatten() {
            let path = entry.path();
            let name = path.file_name().unwrap().to_string_lossy();

            if path.is_dir() {
                // Skip configured directories
                if self.skip_dirs.contains(&name.to_string()) {
                    continue;
                }

                // Recursively collect from subdirectories
                let new_prefix = if prefix.is_empty() {
                    name.to_string()
                } else {
                    format!("{prefix}/{name}")
                };
                self.collect_files(&path, &new_prefix, code);
            } else if self.matches_extension(&path) {
                // Generate the resource name
                let resource_name = self.extract_name(&path, prefix);

                // Read the file content at build time and embed it as a string literal
                if let Ok(content) = fs::read_to_string(&path) {
                    // Escape any raw string delimiters in the content
                    let escaped = escape_raw_string(&content);
                    writeln!(code, "        (\"{resource_name}\", r#\"{escaped}\"#),").unwrap();
                }
            }
        }
    }

    /// Check if a file matches any of the configured extensions.
    fn matches_extension(&self, path: &Path) -> bool {
        let Some(ext) = path.extension() else {
            return false;
        };
        let ext = ext.to_string_lossy();
        self.extensions.iter().any(|e| e == ext.as_ref())
    }

    /// Extract the resource name from a file path.
    fn extract_name(&self, path: &Path, prefix: &str) -> String {
        let name = path.file_name().unwrap().to_string_lossy();

        // Strip known extensions
        let base_name = self
            .extensions
            .iter()
            .find_map(|ext| name.strip_suffix(&format!(".{}", ext)))
            .unwrap_or(&name);

        if prefix.is_empty() {
            base_name.to_string()
        } else {
            format!("{}/{}", prefix, base_name)
        }
    }
}

/// Escape content for use in a raw string literal.
///
/// Raw strings in Rust use `r#"..."#` syntax. If the content contains `"#`,
/// we need to use more `#` characters.
fn escape_raw_string(content: &str) -> String {
    // For now, we assume content doesn't contain `"#`
    // A more robust solution would count `#` sequences and use more
    content.to_string()
}

/// Helper to get the manifest directory.
pub fn manifest_dir() -> PathBuf {
    PathBuf::from(env::var("CARGO_MANIFEST_DIR").unwrap())
}

/// Helper to get the OUT_DIR.
pub fn out_dir() -> PathBuf {
    PathBuf::from(env::var("OUT_DIR").unwrap())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generator_defaults() {
        let gen = BuiltinGenerator::new("validators");
        assert_eq!(gen.resource_type, "validators");
        assert_eq!(gen.source_dir, "../builtin/validators");
        assert_eq!(gen.output_name, "builtin_validators");
        assert_eq!(gen.function_name, "get_builtin_validators");
        assert_eq!(gen.extensions, vec!["md"]);
    }

    #[test]
    fn test_generator_customization() {
        let gen = BuiltinGenerator::new("prompts")
            .source_dir("custom/prompts")
            .extensions(&["md", "liquid"])
            .skip_dirs(&["workflows"]);

        assert_eq!(gen.source_dir, "custom/prompts");
        assert_eq!(gen.extensions, vec!["md", "liquid"]);
        assert_eq!(gen.skip_dirs, vec!["workflows"]);
    }
}
