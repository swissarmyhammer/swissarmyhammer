{% partial %}

## Coding Standards

Here are our general coding standards. Always follow ALL the rules.

Different languages will have Language Specific Standards. Always follow ALL the rules.

Individual projects will have Project Coding Standards that specify additional rules in CODING_STANDARDS.md. Always follow ALL the rules.

### Repository Specifics

Always put mcp.log and semantic.db in the .gitignore.

### Writing Code

### General

- NEVER use `sed`, use your editing tools
- You MUST ALWAYS read the code:
  - this includes the file you are editing, and the files they reference
  - this includes standard library source, and included open source dependencies
- YOU STRONGLY prefer simple, clean, maintainable solutions over clever or complex ones.
- YOU MUST NEVER refer to temporal context in comments (like "recently refactored" "moved") or code. Comments should be evergreen and describe the code as it is. If you name something "new" or "enhanced" or "improved", you've probably made a mistake and MUST STOP and ask me what to do.
- ACTUALLY DO THE WORK:
  - NEVER put stubs or TODO in the code
  - NEVER create placeholders
  - NEVER create a 'dummy' to replace a library for testing
  - NEVER comment out or stub because of a failing test -- actually FIX the problem
  - NEVER hard code when you need to get real data
  - NEVER mock
- DO NOT make 'helper' functions that simple wrap and delegate.

### Helper Methods

**HELPER METHOD ARE FORBIDDEN**.
Do not create 'helper methods' or 'convenience methods'. Use APIs in the natural form.
If the natural form of an API is consistently inconvenient:
- In the current repository? Fix the API!
- Not in the current repository? Leave a comment in the code indicating that the lower level API could use a new method with a suggested name and signature.

### Temporary Files

When you generate temporary or scratch files, make sure to put a comment in the file to clearly note `THIS IS A SCRATCH FILE GENERATED BY A ðŸ¤–`.

### Refactoring

When you are engaged in a large refactoring, you need to work file by file.

- Search and define a list of files you will be changing in this refactoring, create a todo list of these files
- Plan out the change to each file, creating a new issue with the mcp issue tool for each file
  - in each issue, clearly state the goal of the refactoring
  - in each issue, clearly state the change you will be making
  - in each issue, clearly state what tests need to be created
  - mark it off your todo list once the issue is created
  - notify the user that an issue was created using the notify_create tool

Creating issues rather than just 'going for it' ensures working in small, testable chunks.

### Data Structures

You have a type system. Use it.

- Think deeply any time you define a data structure
- If you want to use a primitive type, ask yourself 'is this REALLY a primitive, or do I need a new type?'
- YOU MUST use ULID, which is a sortable identifier instead of UUID
- DO NOT use primitive types as identifiers, create new or wrapper types so that identifiers cannot be mixed up
  - DO NOT use raw String, Int, ULID, UUID as a state, key, or identifier - always create a new type in these cases
- Search for, and use existing non primitive types rather than make new ones needlessly

### Duplication

- YOU MUST Identify common patterns and create shared utilities rather than repeating code
- YOU MUST WORK HARD to reduce code duplication, even if the refactoring takes extra effort
- YOU MUST search the code base to find and use existing functionality to avoid re implementing
- YOU MUST NOT duplicate library or server logic in the UI or CLI
- YOU MUST NEVER implement ANY backward compatibility unless specifically directed by the user
- YOU MUST look at the existing code to find and use consistent patterns, approaches, and naming
- YOU MUST think hard about your change and where else in the code base is affected, or should change to match
- YOU MUST avoid duplicate code paths that lead to inconsistent behavior

### Coding Rules

- DO NOT turn data into strings just to compare for equality
- DO implement equality methods in a language appropriate pattern to compare for equality
- DO implement a solution that works correctly for all valid inputs, not just the test cases
- DO NOT hard-code values or create solutions that only work for specific test inputs

### Security

- DO NOT proactively add security features. Security is an important area, and should only be added when you are EXPLICITLY asked by the user.

### Testing

Focus on understanding the problem requirements and coding tests that prove the code meets the requirements.

- YOU MUST NEVER create performance tests or benchmarks unless explicitly asked by the user
- YOU MUST comprehensively cover ALL functionality with tests
- YOU MUST follow Test Driven Development [TDD](https://en.wikipedia.org/wiki/Test-driven_development):
    1. Write a failing test that correctly validates the desired functionality
    2. Run the test to confirm it fails as expected
    3. Write ONLY enough code to make the failing test pass
    4. Run the test to confirm success
    5. Refactor if needed while keeping tests green
- YOU MUST NEVER implement mocks in end to end tests -- ALWAYS use real data and real APIs.
- YOU MUST NEVER ignore system or test output -- logs and messages often contain CRITICAL information
- Test output MUST BE PRISTINE TO PASS -- if logs are expected to contain errors, these MUST be captured and tested
- YOU MUST NEVER stop work when you still have failing tests -- get those tests passing
- YOU MUST NEVER write performance tests while doing TDD, only write performance tests if explicitly asked
- YOU MUST NEVER run tests with any timeout parameters to the tests, let them run
- YOU MUST make tests that are too slow (> 5s) run faster

## Language Specific Standards

### Rust

- Always compile and check your work with `cargo build` after an editass
- Always format your files with `cargo fmt`
  - Format all files with `cargo fmt --all`
- Test with https://nexte.st
  - `cargo nextest run --fail-fast` is the way
  - do not use `--no-capture` unless you are debugging specific tests -- it is VERY SLOW
  - if `cargo nextest` is not available, install with `cargo install cargo-nextest`
- Always lint your files with `cargo clippy`
  - All lint errors and warnings should be included as todo items in code review
- Use `tracing` not `eprintln`
- When making functions, there are two preferred designs
  - A function takes a single parameter that is a structure or object
  - A function takes two parameters, a context object, and a single parameter that is a structure or object
  - AVOID making functions that take a long list of primitives as parameters
- Never #[allow(dead_code)], delete it -- we have source control these days
- Never create a feature in a Cargo.toml unless EXPLICITLY requested by the user
- Never ignore or remove a unit tests.

### React

- Always use TypeScript with full type annotations
- Always format your files with `npx prettier`
  - Format all files with `npx prettier --write .`
- Always lint your files with `npx eslint` and `npx tsc --noEmit`
- If not otherwise specified, use MUI.
- Style via sx prop using MUI or styled API; avoid inline styles.
- Keep file â‰¤ 120 lines (excluding comments) and auto-format with Prettier.
- Include JSDoc for the component and each prop.
  - Append a short usage example in the JSDoc for each Component.
- Component guidelines
  - Always create functional components
  - Always use Hooks
  - Containers
    - Maintain State
    - Wrap Presenters
    - Handle Events from Presenters
  - Presenters
    - Are Stateless
    - Present visual data
    - Raise Events to Handlers
  - Create custom hooks as needed
  - Create Props interfaces separately, for example

    ```ts
      // Define the type for the component's props
      interface MyComponentProps {
        name: string;
        age?: number; // Optional prop
      }

      // Define the functional component
      const MyComponent: React.FC<MyComponentProps> = ({ name, age }) => {
        return (
          <div>
            <h1>Hello, {name}!</h1>
            {age && <p>You are {age} years old.</p>}
          </div>
        );
      };

      export default MyComponent;
      ```

### Dart and Flutter

- If `flutter` is not available, use `fvm`
- Look for opportunities to create a new Widget to eliminate duplicated code in build methods and replace duplication with a new shared widget
- Always create Material widgets, using the Material theme system
- Do not hard code pixel values, ever
  - use the text style font size or values from the Theme from the current context
- DO NOT HARD CODE ANYTHING IN PIXELS, use ems relative to the theme font size or use the theme padding
- DO NOT hard code colors, ever -- make a smart choice from the theme colors based on the standard material widgets
- Use Padding rather than SizedBox
- Use Actions and Intents
  - Widgets need to `maybeInvoke` intents to allow optional handling
  - If you have an `on<Event>` type callback, you need a matching intent to allow Action handling
- If you cannot find `flutter` use `fvm flutter` instead
- `flutter analyze` before you commit code, fix all warnings and errors
- `flutter test` before you commit code, fix all failing tests
- Create unit tests for Widgets
  - Test text display to make sure the Widget displays the correct text
  - Test Action/Intent to make sure the Widget behaves as expected
- Create a Storybook story for Widget
- Widget guidelines
  - Containers maintain state and handle intents via Actions
  - Presenters are stateless and present visual data and raise Intents
  - Use [flutter_hooks](https://pub.dev/packages/flutter_hooks), not StatefulWidget
  - Create custom hooks as needed
