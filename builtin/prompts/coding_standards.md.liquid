{% partial %}

## Coding Standards

Always follow ALL the rules from:
1. General coding standards (below)
2. Language Specific Standards (below)
3. Project Coding Standards in CODING_STANDARDS.md (if present)

### Writing Code

### General

- NEVER use `sed`, use your editing tools
- You MUST ALWAYS read the code:
  - this includes the file you are editing, and the files they reference
  - this includes standard library source, and included open source dependencies
- YOU STRONGLY prefer simple, clean, maintainable solutions over clever or complex ones.
- YOU MUST NEVER refer to temporal context in comments (like "recently refactored" "moved") or code. Comments should be evergreen and describe the code as it is. If you name something "new" or "enhanced" or "improved", you've probably made a mistake and MUST STOP and ask me what to do.
- ACTUALLY DO THE WORK:
  - NEVER create a 'dummy' to replace a library for testing
  - NEVER comment out or stub because of a failing test -- actually FIX the problem
  - NEVER hard code when you need to get real data

### Data Structures

When you have a type system -- *use it*.

- Think deeply any time you define a data structure
- If you want to use a primitive type, ask yourself 'is this REALLY a primitive, or do I need a new type?'
- YOU MUST use ULID, which is a sortable identifier instead of UUID
- DO NOT use primitive types as identifiers, create new or wrapper types so that identifiers cannot be mixed up
  - DO NOT use raw String, Int, ULID, UUID as a state, key, or identifier - always create a new type in these cases
- Search for, and use existing non primitive types rather than make new ones needlessly

### Security

- DO NOT proactively add security features. Security is an important area, and should only be added when you are EXPLICITLY asked by the user.

### Testing

Focus on understanding the problem requirements and coding tests that prove the code meets the requirements.

- **IMPORTANT** YOU MUST NEVER create or suggest performance tests or benchmarks unless explicitly asked by the user
- YOU MUST comprehensively cover ALL functionality with tests
- YOU MUST follow Test Driven Development [TDD](https://en.wikipedia.org/wiki/Test-driven_development):
    1. Write a failing test that correctly validates the desired functionality
    2. Run the test to confirm it fails as expected
    3. Write ONLY enough code to make the failing test pass
    4. Run the test to confirm success
    5. Refactor if needed while keeping tests green

It is **CRITICAL** that all tests pass before code is committed, no exceptions, no matter why the test is failing.

### Component Architecture Pattern

Many UI frameworks follow a Container/Presenter pattern:

- **Containers**
  - Maintain State
  - Wrap Presenters
  - Handle Events from Presenters
- **Presenters**
  - Are Stateless
  - Present visual data
  - Raise Events to Handlers

## Language Specific Standards

### Rust

- Always compile and check your work with `cargo build` after an edit
- There is no such thing as a 'cached compilation artifact'
- Format with `cargo fmt` (or `cargo fmt --all` for all files)
- Test with https://nexte.st
  - `cargo nextest run --fail-fast` is the way
  - do not use `--no-capture` unless you are debugging specific tests -- it is VERY SLOW
  - if `cargo nextest` is not available, install with `cargo install cargo-nextest`
- *Important*: avoid using `cargo test` instead of `cargo nextest` -- `cargo test` is SLOW and does not parallelize tests
- Lint with `cargo clippy` - all lint errors and warnings should be included as todo items in code review
- Use `tracing` not `eprintln`
- When making functions, there are two preferred designs
  - A function takes a single parameter that is a structure or object
  - A function takes two parameters, a context object, and a single parameter that is a structure or object
  - AVOID making functions that take a long list of primitives as parameters
- Never #[allow(dead_code)], delete it -- we have source control these days
- Never create a feature in a Cargo.toml unless EXPLICITLY requested by the user
- Never ignore or remove a unit tests.

### React

- Always use TypeScript with full type annotations
- Format with `npx prettier` (or `npx prettier --write .` for all files)
- Lint with `npx eslint` and `npx tsc --noEmit`
- If not otherwise specified, use vite.
- If not otherwise specified, use MUI.
    - Style via sx prop using MUI or styled API; avoid inline styles.
- DO NOT use absolute positioning for layout.
- Keep file â‰¤ 250 lines (excluding comments) and auto-format with Prettier.
- Include JSDoc for the component and each prop.
  - Append a short usage example in the JSDoc for each Component.
- Component guidelines
  - Always create functional components
  - Always use Hooks
  - Follow the Component Architecture Pattern (see above)
  - Create custom hooks as needed
  - Create Props interfaces separately, for example

    ```ts
      // Define the type for the component's props
      interface MyComponentProps {
        name: string;
        age?: number; // Optional prop
      }

      // Define the functional component
      const MyComponent: React.FC<MyComponentProps> = ({ name, age }) => {
        return (
          <div>
            <h1>Hello, {name}!</h1>
            {age && <p>You are {age} years old.</p>}
          </div>
        );
      };

      export default MyComponent;
      ```
    - Do not get stuck waiting for StoryBook -- remember that it exists to show UI widgets, it is not a pass/fail test system

### Dart and Flutter

- If `flutter` is not available, use `fvm`
- Look for opportunities to create a new Widget to eliminate duplicated code in build methods and replace duplication with a new shared widget
- Always create Material widgets, using the Material theme system
- Do not hard code pixel values, ever
  - use the text style font size or values from the Theme from the current context
- DO NOT HARD CODE ANYTHING IN PIXELS, use ems relative to the theme font size or use the theme padding
- DO NOT hard code colors, ever -- make a smart choice from the theme colors based on the standard material widgets
- Use Padding rather than SizedBox
- Use Actions and Intents
  - Widgets need to `maybeInvoke` intents to allow optional handling
  - If you have an `on<Event>` type callback, you need a matching intent to allow Action handling
- If you cannot find `flutter` use `fvm flutter` instead
- Before committing code:
  1. Run `flutter analyze` and fix all warnings and errors
  2. Run `flutter test` and fix all failing tests
- Create unit tests for Widgets
  - Test text display to make sure the Widget displays the correct text
  - Test Action/Intent to make sure the Widget behaves as expected
- Create a Storybook story for Widget
- Widget guidelines
  - Follow the Component Architecture Pattern (see above)
  - Use [flutter_hooks](https://pub.dev/packages/flutter_hooks), not StatefulWidget
  - Create custom hooks as needed
