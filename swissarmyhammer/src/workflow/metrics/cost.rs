//! Cost tracking metrics for workflow execution

use crate::cost::{ApiCallId, CostSessionId};
use chrono::{DateTime, Utc};
use rust_decimal::Decimal;
use rust_decimal::prelude::ToPrimitive;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::time::Duration;

/// Cost tracking metrics for a workflow run
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CostMetrics {
    /// Associated cost session ID
    pub session_id: CostSessionId,
    /// Total calculated cost for the workflow run
    pub total_cost: Decimal,
    /// Total input tokens used
    pub total_input_tokens: u32,
    /// Total output tokens generated
    pub total_output_tokens: u32,
    /// Total number of API calls made
    pub api_call_count: usize,
    /// Cost breakdown by workflow action
    pub cost_by_action: HashMap<String, ActionCostBreakdown>,
    /// When cost tracking started
    pub started_at: DateTime<Utc>,
    /// When cost tracking completed
    pub completed_at: Option<DateTime<Utc>>,
}

/// Cost breakdown for a specific workflow action
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ActionCostBreakdown {
    /// Name/ID of the action
    pub action_name: String,
    /// Cost for this specific action
    pub cost: Decimal,
    /// Input tokens used by this action
    pub input_tokens: u32,
    /// Output tokens generated by this action
    pub output_tokens: u32,
    /// Number of API calls made by this action
    pub api_call_count: usize,
    /// API call IDs associated with this action
    pub api_call_ids: Vec<ApiCallId>,
    /// Duration spent on this action
    pub duration: Option<Duration>,
}

impl CostMetrics {
    /// Create new cost metrics for a session
    pub fn new(session_id: CostSessionId) -> Self {
        Self {
            session_id,
            total_cost: Decimal::ZERO,
            total_input_tokens: 0,
            total_output_tokens: 0,
            api_call_count: 0,
            cost_by_action: HashMap::new(),
            started_at: Utc::now(),
            completed_at: None,
        }
    }

    /// Complete the cost metrics tracking
    pub fn complete(&mut self) {
        self.completed_at = Some(Utc::now());
    }

    /// Add cost breakdown for an action
    pub fn add_action_cost(&mut self, action_name: String, breakdown: ActionCostBreakdown) {
        self.cost_by_action.insert(action_name, breakdown);
        self.recalculate_totals();
    }

    /// Get total tokens (input + output)
    pub fn total_tokens(&self) -> u32 {
        self.total_input_tokens + self.total_output_tokens
    }

    /// Check if cost tracking is completed
    pub fn is_completed(&self) -> bool {
        self.completed_at.is_some()
    }

    /// Calculate cost per token (total cost / total tokens)
    pub fn cost_per_token(&self) -> Option<Decimal> {
        let total_tokens = self.total_tokens();
        if total_tokens > 0 {
            Some(self.total_cost / Decimal::from(total_tokens))
        } else {
            None
        }
    }

    /// Calculate token efficiency ratio (output tokens / input tokens)
    pub fn token_efficiency_ratio(&self) -> Option<f64> {
        if self.total_input_tokens > 0 {
            Some(self.total_output_tokens as f64 / self.total_input_tokens as f64)
        } else {
            None
        }
    }

    /// Calculate average cost per API call
    pub fn average_cost_per_call(&self) -> Option<Decimal> {
        if self.api_call_count > 0 {
            Some(self.total_cost / Decimal::from(self.api_call_count))
        } else {
            None
        }
    }

    /// Get cost attribution percentages by action
    pub fn cost_attribution(&self) -> HashMap<String, f64> {
        if self.total_cost.is_zero() {
            return HashMap::new();
        }

        self.cost_by_action
            .iter()
            .map(|(action, breakdown)| {
                let percentage = (breakdown.cost / self.total_cost).to_f64().unwrap_or(0.0) * 100.0;
                (action.clone(), percentage)
            })
            .collect()
    }

    /// Identify the most expensive action
    pub fn most_expensive_action(&self) -> Option<(&String, &ActionCostBreakdown)> {
        self.cost_by_action
            .iter()
            .max_by(|a, b| a.1.cost.cmp(&b.1.cost))
    }

    /// Identify the most token-intensive action
    pub fn most_token_intensive_action(&self) -> Option<(&String, &ActionCostBreakdown)> {
        self.cost_by_action
            .iter()
            .max_by_key(|&(_, breakdown)| breakdown.total_tokens())
    }

    /// Recalculate totals from action breakdowns
    fn recalculate_totals(&mut self) {
        self.total_cost = self
            .cost_by_action
            .values()
            .map(|breakdown| breakdown.cost)
            .sum();

        self.total_input_tokens = self
            .cost_by_action
            .values()
            .map(|breakdown| breakdown.input_tokens)
            .sum();

        self.total_output_tokens = self
            .cost_by_action
            .values()
            .map(|breakdown| breakdown.output_tokens)
            .sum();

        self.api_call_count = self
            .cost_by_action
            .values()
            .map(|breakdown| breakdown.api_call_count)
            .sum();
    }
}

impl ActionCostBreakdown {
    /// Create new action cost breakdown
    pub fn new(action_name: String) -> Self {
        Self {
            action_name,
            cost: Decimal::ZERO,
            input_tokens: 0,
            output_tokens: 0,
            api_call_count: 0,
            api_call_ids: Vec::new(),
            duration: None,
        }
    }

    /// Add API call to this action's breakdown
    pub fn add_api_call(
        &mut self,
        call_id: ApiCallId,
        cost: Decimal,
        input_tokens: u32,
        output_tokens: u32,
    ) {
        self.api_call_ids.push(call_id);
        self.cost += cost;
        self.input_tokens += input_tokens;
        self.output_tokens += output_tokens;
        self.api_call_count += 1;
    }

    /// Get total tokens for this action
    pub fn total_tokens(&self) -> u32 {
        self.input_tokens + self.output_tokens
    }

    /// Set duration for this action
    pub fn set_duration(&mut self, duration: Duration) {
        self.duration = Some(duration);
    }
}
