# SwissArmyHammer Coding Standards

## Repository Specifics

Always put mcp.log and semantic.db in the .gitignore.

## Writing Code

### General

- NEVER use `sed`, use your editing tools
- You MUST ALWAYS read the code:
  - this includes the file you are editing, and the files they reference
  - this includes standard library source, and included open source dependencies
- YOU STRONGLY prefer simple, clean, maintainable solutions over clever or complex ones.
- YOU MUST NEVER refer to temporal context in comments (like "recently refactored" "moved") or code. Comments should be evergreen and describe the code as it is. If you name something "new" or "enhanced" or "improved", you've probably made a mistake and MUST STOP and ask me what to do.
- ACTUALLY DO THE WORK:
  - NEVER put stubs or TODO in the code
  - NEVER create placeholders
  - NEVER create a 'dummy' to replace a library for testing
  - NEVER comment out or stub because of a failing test -- actually FIX the problem
  - NEVER hard code when you need to get real data
  - NEVER mock
- If a file has more than 500 lines of code, consider refactoring it into smaller files.
    - Specifically look for files that have multiple classes, functions, or types that are all separatedly public -- roughly speaking each public class, function, or type should be in its own file.

### Helper Methods

**HELPER METHOD ARE FORBIDDEN**.
Do not create 'helper methods' or 'convenience methods'. Use APIs in the natural form.
If the natural form of an API is consistently inconvenient:
- In the current repository? Fix the API!
- Not in the current repository? Leave a comment in the code indicating that the lower level API could use a new method with a suggested name and signature.

### Temporary Files

When you generate temporary or scratch files, make sure to put a comment in the file to clearly note `THIS IS A SCRATCH FILE GENERATED BY A ðŸ¤–`.

### Refactoring

When you are engaged in a large refactoring, you need to work file by file.

- Search and define a list of files you will be changing in this refactoring, create a todo list of these files with todo_create
- Plan out the change to each file, creating a new todo list item with todo_create
  - in each todo, clearly state the goal of the refactoring
  - in each todo, clearly state the change you will be making
  - in each todo, clearly state what tests need to be created
- Work the todo list
- todo_mark_complete it off your todo list once the issue is created
- notify_create the user that an issue was created using the notify_create tool

Creating issues rather than just 'going for it' ensures working in small, testable chunks.

### Data Structures

You have a type system. Use it.

- Think deeply any time you define a data structure
- If you want to use a primitive type, ask yourself 'is this REALLY a primitive, or do I need a new type?'
- YOU MUST use ULID, which is a sortable identifier instead of UUID
- DO NOT use primitive types as identifiers, create new or wrapper types so that identifiers cannot be mixed up
  - DO NOT use raw String, Int, ULID, UUID as a state, key, or identifier - always create a new type in these cases
- Search for, and use existing non primitive types rather than make new ones needlessly

### Duplication

- YOU MUST Identify common patterns and create shared utilities rather than repeating code
- YOU MUST WORK HARD to reduce code duplication, even if the refactoring takes extra effort
- YOU MUST search the code base to find and use existing functionality to avoid re implementing
- YOU MUST NOT duplicate library or server logic in the UI or CLI
- YOU MUST NEVER implement ANY backward compatibility unless specifically directed by the user
- YOU MUST look at the existing code to find and use consistent patterns, approaches, and naming
- YOU MUST think hard about your change and where else in the code base is affected, or should change to match
- YOU MUST avoid duplicate code paths that lead to inconsistent behavior

### Coding Rules

- DO NOT turn data into strings just to compare for equality
- DO implement equality methods in a language appropriate pattern to compare for equality
- DO implement a solution that works correctly for all valid inputs, not just the test cases
- DO NOT hard-code values or create solutions that only work for specific test inputs

### Security

- DO NOT proactively add security features. Security is an important area, and should only be added when you are EXPLICITLY asked by the user.

### Testing

Focus on understanding the problem requirements and coding tests that prove the code meets the requirements.

- YOU MUST NEVER create performance tests or benchmarks unless explicitly asked by the user
- YOU MUST comprehensively cover ALL functionality with tests
- YOU MUST follow Test Driven Development [TDD](https://en.wikipedia.org/wiki/Test-driven_development):
    1. Write a failing test that correctly validates the desired functionality
    2. Run the test to confirm it fails as expected
    3. Write ONLY enough code to make the failing test pass
    4. Run the test to confirm success
    5. Refactor if needed while keeping tests green
- YOU MUST NEVER implement mocks in end to end tests -- ALWAYS use real data and real APIs.
- YOU MUST NEVER ignore system or test output -- logs and messages often contain CRITICAL information
- Test output MUST BE PRISTINE TO PASS -- if logs are expected to contain errors, these MUST be captured and tested
- YOU MUST NEVER stop work when you still have failing tests -- get those tests passing
- YOU MUST NEVER write performance tests while doing TDD, only write performance tests if explicitly asked
- YOU MUST NEVER run tests with any timeout parameters to the tests, let them run
- YOU MUST make tests that are too slow (> 5s) run faster

## Language Specific Standards

### Rust

- Always compile and check your work with `cargo build` after an edit
- There is no such thing as a 'cached compilation artifact'
- Always format your files with `cargo fmt`
  - Format all files with `cargo fmt --all`
- Test with https://nexte.st
  - `cargo nextest run --fail-fast` is the way
  - do not use `--no-capture` unless you are debugging specific tests -- it is VERY SLOW
  - if `cargo nextest` is not available, install with `cargo install cargo-nextest`
- Always lint your files with `cargo clippy`
  - All lint errors and warnings should be included as todo items in code review
- Use `tracing` not `eprintln`
- When making functions, there are two preferred designs
  - A function takes a single parameter that is a structure or object
  - A function takes two parameters, a context object, and a single parameter that is a structure or object
  - AVOID making functions that take a long list of primitives as parameters
- Never #[allow(dead_code)], delete it -- we have source control these days
- Never create a feature in a Cargo.toml unless EXPLICITLY requested by the user
- Never ignore or remove a unit tests.