# Migration Plan: Eliminate Issues and Memos

**THIS IS A SCRATCH FILE GENERATED BY A ü§ñ**

## Date
2025-11-12

## Goal
Simplify SwissArmyHammer architecture by consolidating on Rules + Todos only.

## Philosophy
- **Rules** = Permanent executable specifications (what should be true)
- **Code + Comments** = Implementation and historical context (what is true and why)
- **Todos** = Ephemeral task tracking with rich markdown context (what to do next)

Everything else is redundant.

## Systems to Eliminate

### Issues System
- **Crates**: `swissarmyhammer-issues`
- **MCP Tools**: `issue_create`, `issue_show`, `issue_list`, `issue_update`, `issue_mark_complete`, `issue_all_complete`
- **CLI Commands**: `sah issue ...`
- **Storage**: `.swissarmyhammer/issues/`
- **Workflows using it**: `do_issue`, `implement`, `test`

### Memos System
- **Crates**: `swissarmyhammer-memoranda`
- **MCP Tools**: `memo_create`, `memo_get`, `memo_list`, `memo_get_all_context`
- **CLI Commands**: `sah memo ...`
- **Storage**: `.swissarmyhammer/memos/`
- **Current usage**: System prompt context injection

## New Tool Needed

### rule_create
Create rules from specifications/requirements.

**Purpose**: Convert external issues/requirements into executable rules.

## Key Decision: NO MIGRATION

**We will NOT migrate existing issues/memos.**
- No backward compatibility needed
- Just ignore the directories (add to .gitignore)
- No data conversion
- Clean slate approach

Any valuable patterns from old memos can be recreated as rules when needed.

## rule_create Tool Design

### Design Decisions
- ‚úÖ **Location**: `.swissarmyhammer/rules/` with subdirectory support
  - Example: `.swissarmyhammer/rules/code-quality/my-rule.md`
  - Should already work if manually created
- ‚úÖ **Category**: Derived from subdirectory in filename
  - User specifies: `name: "code-quality/my-rule"`
  - Creates: `.swissarmyhammer/rules/code-quality/my-rule.md`
  - Category field in YAML is redundant (can be removed from existing rules)
- ‚úÖ **Auto-generate frontmatter**: AI agent provides structured parameters
- ‚úÖ **Description**: NOT in frontmatter - it's the markdown body
- ‚úÖ **Primary caller**: AI agents via MCP, not users directly
- ‚úÖ **No validation**: Just write the file, don't validate
- ‚úÖ **Directory creation**: Create directories if they don't exist (mkdir -p behavior)

### Minimal Required Interface
```json
{
  "name": "code-quality/no-global-state",
  "content": "Check for global mutable state...",
  "severity": "error",
  "tags": ["maintainability", "testing"]  // optional
}
```

### Generated File
```markdown
---
severity: error
tags: ["maintainability", "testing"]
---

Check for global mutable state...
```

### Rationale
- NO title - redundant with filename, can drift
- NO description - the content IS the description
- NO category - redundant with directory structure
- NO auto_fix - future feature, not needed now
- **ONLY**: severity (required) + tags (optional)

## Workflow Changes

### Workflows that use issues
- `do_issue.md` - Autonomously work through the next open issue
- `implement.md` - Loop through all issues until complete

### Prompts that use issues
- `are_issues_complete.md` - Uses `issue_all_complete` tool
- `issue/complete.md` - Uses `issue_show` and `issue_mark_complete` tools
- `issue/placeholders.md` - Uses `issue_create` to create issues from TODOs
- `code/issue.md` - Uses `issue_show` (next), `issue_update` (add notes), implements solution

### Issue System Features Being Lost
- Issues were living documents that got updated during implementation
- "Proposed Solution" sections added to issues
- Implementation notes kept in the issue file
- Rich markdown context for work in progress

### Replacement Pattern
- ‚úÖ "next item to work on" ‚Üí `todo_show` with `item="next"`
- ‚úÖ "are we done?" ‚Üí Check if todo.yaml exists / all todos complete
- ‚úÖ "mark complete" ‚Üí `todo_mark_complete`
- ‚úÖ "find TODOs in code" ‚Üí Create "no-todos" rule, violations auto-create todos
- ‚úÖ "implementation notes" ‚Üí Code comments (user decision)
- ‚úÖ "proposed solution" ‚Üí Just implement (or put in scratch file if needed)

### Workflows to Delete
- `do_issue.md` ‚Üí Replace with `do_todos` (already exists!)
- `implement.md` ‚Üí Replace with simpler "do all todos" workflow

### Prompts to Delete
- `are_issues_complete.md`
- `issue/complete.md`
- `issue/placeholders.md`
- `code/issue.md`

### Prompts to Update
- `commit.md` - May reference issues (need to check)
- `plan.md` - May reference issues (need to check)
- `test.md` - May reference issues (need to check)

### Workflow Renaming/Simplification
- `do_issue` ‚Üí DELETE
- `implement` ‚Üí DELETE
- `do_todos` ‚Üí RENAME to `do` (becomes the main implementation loop)
- CLI: Add `sah do` command (runs the `do` workflow)

### Updated Workflow Trinity
- `do` - Work through all todos until done
- `review` - Review code quality (already uses rules)
- `test` - Run tests until passing

## Plan Workflow Changes

### Current behavior
- Takes spec file parameter: `plan_filename`
- Reads spec markdown file
- Creates multiple issues (numbered FOO_000001, FOO_000002, etc.)
- Each issue is a step with rich context, diagrams, references

### New behavior: ‚úÖ OPTION B - Rules + Todos

**Plan workflow:**
1. Read spec file
2. Create **rules** using `rule_create`
   - Define "what success looks like" (acceptance criteria)
   - Example: "API endpoint /users must exist and return 200"
   - These are permanent, checked by `rules_check`
3. Create **todos** using `todo_create` with rich markdown context
   - Break spec into implementation steps
   - Context can include:
     - Mermaid diagrams
     - Code examples
     - References to spec file
     - Implementation notes
     - Multi-paragraph explanations
   - **Key insight**: Todo `context` is "just a string" - can be as rich as old issues!
4. As implementation progresses:
   - Work through todos with `sah do`
   - Run `rules_check` which auto-creates more todos for violations
   - Complete todos ‚Üí auto-GC after 24h

### What we keep
- ‚úÖ Rich context (markdown, diagrams, examples in todo context field)
- ‚úÖ Permanent success criteria (rules)
- ‚úÖ Implementation steps (todos)

### What we lose
- ‚ùå Numbered individual markdown files per step
- ‚ùå Ability to "update" a todo during implementation (but notes go in code comments anyway)
- ‚ùå Permanent record of implementation steps (but rules remain as the spec)

### New plan prompt needs to
- Call `rule_create` for acceptance criteria
- Call `todo_create` for implementation steps with RICH markdown context
- Reference spec file in both rules and todos

## System Prompts
- ‚úÖ ANSWER: Just delete memo_get_all_context usage - no replacement needed
- Rules get checked via rules_check, not injected as context

## Summary

### What we're building
1. `rule_create` MCP tool - Create project-specific rules from specs
2. Migration to eliminate issues/memos systems entirely
3. Simplified architecture: Rules (permanent) + Todos (ephemeral rich markdown) + Code Comments (historical context)

### What gets deleted
- Entire `swissarmyhammer-issues` crate
- Entire `swissarmyhammer-memoranda` crate
- 6+ MCP tools (issue_*, memo_*)
- CLI commands (sah issue, sah memo)
- `.swissarmyhammer/issues/` directory and all content
- `.swissarmyhammer/memos/` directory and all content
- Builtin workflows: `do_issue`, `implement`
- Builtin prompts: `are_issues_complete`, `issue/complete`, `issue/placeholders`, `code/issue`

### What gets created
- `rule_create` MCP tool
- `todo_list` MCP tool (inspired by `issue_list` - list all todos) ‚úÖ DONE
- `sah do` CLI command (runs the `do` workflow)
- `sah todos` CLI command (lists all current todos)

### What gets renamed
- `do_todos` workflow ‚Üí `do` workflow

### What gets updated
- `plan` workflow/prompt ‚Üí creates rules + todos (not issues)
- `.gitignore` ‚Üí add `.swissarmyhammer/issues/` and `.swissarmyhammer/memos/` (stop tracking them)

### The New Workflow
1. **Plan**: `sah plan spec.md`
   - Creates rules (permanent acceptance criteria)
   - Creates todos with rich markdown context (implementation steps with diagrams, examples, etc.)
2. **Do**: `sah do`
   - Works through todos sequentially
   - Loops until all todos complete
3. **Review**: `sah review`
   - Runs `rules_check`
   - Auto-creates todos for violations
4. **Test**: `sah test`
   - Runs tests until passing

### Key Insight
- Todo `context` field can contain rich markdown (diagrams, code examples, multi-paragraph explanations)
- No loss of expressiveness vs old issue files
- Just stored in YAML instead of individual .md files

## Next Steps

1. ‚úÖ **rule_create design** - COMPLETE
2. ‚úÖ **Workflow architecture** - COMPLETE
3. ‚úÖ **Plan workflow update** - COMPLETE (creates rules + rich todos)
4. **Implementation planning:**
   - Estimate size of removal (lines of code, files)
   - Decide implementation order:
     - Option 1: Add rule_create first, then remove issues/memos
     - Option 2: Remove issues/memos first, then add rule_create
     - Option 3: Big bang - do it all at once
   - Create implementation todos or spec file
5. **CLI updates needed:**
   - Add `sah do` command
   - Add `sah todos` command (list all todos)
   - Update any CLI help text that references issues/memos

## Clarifying Questions - ANSWERED

1. ‚úÖ **Builtin rules format**: Keep as-is (don't migrate), only use minimal format for new project-specific rules
2. ‚úÖ **Spec file after plan**: Leave it where it is (user manages it)
3. ‚úÖ **rule_create directory handling**: Create directories if they don't exist (mkdir -p behavior)
4. ‚úÖ **CLI command name**: `sah do` (simple, matches workflow name)
5. ‚úÖ **Delete issues/memos in git**: Don't touch them, just ignore them (add to .gitignore)
6. ‚úÖ **Todo list command**: YES - need `todo_list` MCP tool and `sah todos` CLI command (‚úÖ MCP tool done)

## Open Questions

None! Architecture is complete and agreed upon.

## Rule YAML Frontmatter Reference

Based on the Rule struct and existing builtin rules:

### Fields in Rule Struct
```rust
pub struct Rule {
    pub name: String,                    // Derived from filename
    pub template: String,                // The markdown body
    pub description: Option<String>,     // From frontmatter (optional)
    pub category: Option<String>,        // From frontmatter (optional, redundant with directory)
    pub tags: Vec<String>,              // From frontmatter (defaults to empty)
    pub source: Option<PathBuf>,        // Auto-set by loader (not in frontmatter)
    pub metadata: HashMap<...>,         // Additional frontmatter fields
    pub severity: Severity,             // From frontmatter (required)
    pub auto_fix: bool,                 // From frontmatter (defaults to false)
}
```

### Current Frontmatter Pattern (from builtin rules)
```yaml
---
title: No Hardcoded Secrets
description: Detects hardcoded API keys, passwords, and tokens in code
category: security
severity: error
tags: ["security", "secrets", "credentials"]
---
```

### Fields Explained

**title** (stored in metadata, currently unused!)
- Stored in `rule.metadata["title"]`
- Shows up in all builtin rules
- **NOT USED ANYWHERE** - just loaded and stored
- **Decision for rule_create**: Don't include it

**description** (optional)
- Brief summary of what the rule checks
- Stored in `rule.description` (Optional<String>)
- Separate from the template/body
- **Clarification**: Description IS in frontmatter, body is the checking instructions
- **Decision for rule_create**: Don't include it - content is the description

**category** (optional, redundant)
- String like "security", "code-quality", "accessibility"
- REDUNDANT with directory structure
- **Decision**: Don't include in rule_create

**severity** (required-ish)
- Enum: error, warning, info, hint
- Defaults to Warning if frontmatter exists but no severity specified
- Defaults to Error if no frontmatter at all
- **Best practice**: Always specify explicitly
- **Decision for rule_create**: REQUIRED parameter

**tags** (optional)
- Array of strings for cross-cutting organization
- Defaults to empty vec
- Used for filtering beyond categories
- **Decision for rule_create**: OPTIONAL parameter

**auto_fix** (optional, future)
- Boolean, defaults to false
- Not used yet (future feature)
- **Decision for rule_create**: Don't include it

### Template Syntax
Rules support Liquid-like template syntax:
- `{{ language }}` - Substituted with the file's language
- `{% include "_partials/report-format" %}` - Include partial templates
- `{% partial %}` - Mark a file as a partial (not a checkable rule)

### Severity Defaults (from rule_loader.rs)
- **If frontmatter exists but no severity**: Warning
- **If no frontmatter at all**: Error
- **Best practice**: Always specify severity explicitly

### For rule_create Tool

**FINAL DECISION: Minimal Frontmatter Only**

```yaml
---
severity: error
tags: ["tag1", "tag2"]  # optional
---
```

**That's it.** No title, no description, no category, no auto_fix.

**rule_create Parameters:**
- `name` (required) - Path like "code-quality/no-global-state"
- `content` (required) - The checking instructions (markdown body)
- `severity` (required) - "error" | "warning" | "info" | "hint"
- `tags` (optional) - Array of strings like ["maintainability", "testing"]

## Notes

Architecture planning session completed 2025-11-12. All design questions resolved. Ready for implementation.
