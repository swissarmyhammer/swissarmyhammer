# Rules Check Todo Creation Layering Violation

**THIS IS A SCRATCH FILE GENERATED BY A ü§ñ**

## Date
2025-11-13

## Problem

The `rules_check` MCP tool bypasses the `todo_create` MCP tool interface and goes directly to `TodoStorage` implementation.

**Location**: `swissarmyhammer-tools/src/mcp/tools/rules/check/mod.rs:197-207`

```rust
async fn create_todo_for_violation(violation: &RuleViolation) -> Result<TodoId, McpError> {
    let task = format!("Fix {} violation in {}", ...);
    let context = format!("## Rule Violation\n...");

    // WRONG: Direct storage access
    let storage = TodoStorage::new_default().map_err(...)?;
    let (todo_item, _gc_count) = storage
        .create_todo_item(task, Some(context))
        .await
        .map_err(...)?;

    Ok(todo_item.id)
}
```

## Why This Is Wrong

### 1. Layering Violation
- MCP tools should call other MCP tools through their public interface
- `rules_check` should use `todo_create` tool, not TodoStorage directly
- Bypassing the tool interface couples to implementation details

### 2. Duplicates Logic
- `todo_create` tool already has parameter validation
- `todo_create` tool already has error handling
- `todo_create` tool already sends progress notifications
- rules_check reimplements all of this

### 3. Inconsistent Behavior
- If `todo_create` tool behavior changes (validation, notifications, etc.), rules_check won't reflect it
- Two different code paths for creating todos
- Can lead to different error messages and behaviors

### 4. Testing Implications
- Tests for `todo_create` don't cover usage from rules_check
- Have to test todo creation in rules_check separately
- Can't mock or intercept tool calls for testing

### 5. Tight Coupling
- rules_check depends on TodoStorage implementation
- Changes to storage layer affect rules_check
- Can't swap storage implementations without changing rules_check

## Correct Approach

### Option A: Call todo_create Tool via ToolRegistry

```rust
async fn create_todo_for_violation(
    context: &ToolContext,
    violation: &RuleViolation
) -> Result<TodoId, McpError> {
    let task = format!("Fix {} violation in {}", ...);
    let context_str = format!("## Rule Violation\n...");

    // Call the todo_create tool through the tool registry
    let request = json!({
        "task": task,
        "context": context_str
    });

    let response = context.tool_registry
        .execute_tool("todo_create", request, context)
        .await?;

    // Parse the response to get todo_id
    let todo_id = response["todo_item"]["id"]
        .as_str()
        .ok_or(McpError::internal_error("No todo_id in response", None))?;

    Ok(TodoId::from_string(todo_id.to_string())?)
}
```

### Option B: Shared Helper Function (if tools don't have tool registry access)

If tools can't easily call other tools, create a shared helper in a common module:

```rust
// In swissarmyhammer-tools/src/mcp/shared_utils.rs or similar
pub async fn create_todo_item(
    task: String,
    context: Option<String>
) -> Result<TodoId, McpError> {
    let storage = TodoStorage::new_default()?;
    let (todo_item, _gc_count) = storage.create_todo_item(task, context).await?;
    Ok(todo_item.id)
}
```

But this still bypasses the tool - it's better than duplication but not as good as calling through the tool interface.

### Option C: Refactor ToolContext to Support Tool Calls

Give tools the ability to call other tools:

```rust
impl ToolContext {
    pub async fn call_tool(&self, name: &str, params: Value) -> Result<Value, McpError> {
        // Look up and execute the tool
        self.tool_registry.execute_tool(name, params, self).await
    }
}
```

Then:
```rust
let response = context.call_tool("todo_create", json!({
    "task": task,
    "context": context_str
})).await?;
```

## Architectural Principle

**Tools should compose through their MCP interfaces, not bypass them to reach implementation layers.**

This is like:
- ‚ùå A REST endpoint directly accessing another service's database
- ‚úÖ A REST endpoint calling another service's API

## Benefits of Fixing This

1. **Single code path** for todo creation
2. **Consistent behavior** - all todos created the same way
3. **Better testing** - test tool composition, not storage details
4. **Loose coupling** - tools depend on interfaces, not implementations
5. **Progress notifications** - todo_create's notifications automatically included
6. **Easier changes** - update todo_create once, affects all callers

## Impact Analysis

**Files to change:**
- `swissarmyhammer-tools/src/mcp/tools/rules/check/mod.rs` - Update create_todo_for_violation
- May need to add tool-calling capability to ToolContext if it doesn't exist

**Testing:**
- Existing tests should still pass (behavior unchanged from outside)
- Internal implementation changes only

**Backward compatibility:**
- MCP API unchanged (external callers see no difference)
- Just internal refactoring

## Recommendation

Implement Option C: Add tool-calling capability to ToolContext, then update rules_check to use it.

This establishes the pattern that tools can call other tools through proper interfaces, which will be useful for other tool compositions going forward.
