# SwissarmyhammerDirectory Struct Design

**THIS IS A SCRATCH FILE GENERATED BY A ðŸ¤–**

## Date
2025-11-13

## Problem

Currently, .swissarmyhammer directory initialization is scattered across multiple crates with inconsistent approaches:
- Multiple utility functions (`get_or_create_swissarmyhammer_directory`, `get_swissarmyhammer_dir`)
- Each crate creates its own subdirectories
- No central representation of the directory structure
- Testing requires environment variable overrides or direct path manipulation
- Unclear which root to use (current dir, git root, home dir)

## Proposed Solution

Create a `SwissarmyhammerDirectory` struct that:
1. Represents the .swissarmyhammer directory and its standard subdirectories
2. Can be created from different roots (home, git root, or custom path)
3. Lives on the ToolContext (available to all MCP tools)
4. Provides consistent access patterns for all subdirectories

## Struct Design

```rust
/// Represents the .swissarmyhammer directory structure
pub struct SwissarmyhammerDirectory {
    /// Root path of the .swissarmyhammer directory
    root: PathBuf,

    /// The root location type (for debugging/logging)
    root_type: DirectoryRootType,
}

pub enum DirectoryRootType {
    /// In user's home directory (~/.swissarmyhammer)
    UserHome,

    /// At Git repository root (./.swissarmyhammer)
    GitRoot,

    /// Custom path (for testing or special cases)
    Custom(PathBuf),
}

impl SwissarmyhammerDirectory {
    /// Create from Git repository root (default for project operations)
    pub fn from_git_root() -> Result<Self> {
        let git_root = find_git_repository_root()
            .ok_or(SwissArmyHammerError::NotInGitRepository)?;
        let root = git_root.join(".swissarmyhammer");
        fs::create_dir_all(&root)?;

        Ok(Self {
            root,
            root_type: DirectoryRootType::GitRoot,
        })
    }

    /// Create from user's home directory (for user-level config/rules)
    pub fn from_user_home() -> Result<Self> {
        let home = dirs::home_dir()
            .ok_or(SwissArmyHammerError::other("Cannot determine home directory"))?;
        let root = home.join(".swissarmyhammer");
        fs::create_dir_all(&root)?;

        Ok(Self {
            root,
            root_type: DirectoryRootType::UserHome,
        })
    }

    /// Create from custom path (for testing)
    pub fn from_custom_root(custom_root: PathBuf) -> Result<Self> {
        let root = custom_root.join(".swissarmyhammer");
        fs::create_dir_all(&root)?;

        Ok(Self {
            root,
            root_type: DirectoryRootType::Custom(custom_root),
        })
    }

    /// Get the root .swissarmyhammer directory path
    pub fn root(&self) -> &Path {
        &self.root
    }

    /// Get a subdirectory path (does not create it)
    ///
    /// Tools request subdirectories by name.
    /// Examples: "todo", "rules", "tmp", "workflow-runs", "transcripts"
    pub fn subdir(&self, name: &str) -> PathBuf {
        self.root.join(name)
    }

    /// Get a subdirectory path, creating it if it doesn't exist
    ///
    /// Tools request subdirectories by name and this ensures they exist.
    pub fn ensure_subdir(&self, name: &str) -> Result<PathBuf> {
        let path = self.root.join(name);
        fs::create_dir_all(&path)?;
        Ok(path)
    }

    /// Get the root type
    pub fn root_type(&self) -> &DirectoryRootType {
        &self.root_type
    }
}
```

## Integration with ToolContext

```rust
pub struct ToolContext {
    // ... existing fields ...

    /// SwissarmyhammerDirectory for this context
    pub sah_dir: SwissarmyhammerDirectory,

    // ... other fields ...
}

impl ToolContext {
    pub fn new(...) -> Result<Self> {
        // Determine which root to use based on context
        let sah_dir = SwissarmyhammerDirectory::from_git_root()?;

        Ok(Self {
            sah_dir,
            // ... other fields ...
        })
    }

    /// Create a context with custom root (for testing)
    pub fn with_custom_root(custom_root: PathBuf, ...) -> Result<Self> {
        let sah_dir = SwissarmyhammerDirectory::from_custom_root(custom_root)?;

        Ok(Self {
            sah_dir,
            // ... other fields ...
        })
    }
}
```

## Usage in Domain Crates

### Before (Inconsistent)

**swissarmyhammer-todo:**
```rust
let swissarmyhammer_dir = get_or_create_swissarmyhammer_directory()?;
let todo_dir = swissarmyhammer_dir.join("todo");
fs::create_dir_all(&todo_dir)?;
```

**swissarmyhammer-issues:**
```rust
let swissarmyhammer_dir = work_dir.join(".swissarmyhammer");
let issues_dir = swissarmyhammer_dir.join("issues");
fs::create_dir_all(&issues_dir).map_err(Error::Io)?;
```

**swissarmyhammer-memoranda:**
```rust
let memos_dir = swissarmyhammer_common::utils::paths::get_swissarmyhammer_dir()?
    .join("memos");
fs::create_dir_all(&memos_dir).await?;
```

### After (Consistent)

**All domain crates:**
```rust
// Get from ToolContext
fn execute(&self, context: &ToolContext, ...) -> Result<...> {
    let todo_dir = context.sah_dir.ensure_subdir("todo")?;
    // Use todo_dir...
}
```

Or if not in a tool context:
```rust
// Direct usage
let sah_dir = SwissarmyhammerDirectory::from_git_root()?;
let todo_dir = sah_dir.ensure_subdir("todo")?;
```

**For tools that just need the path without creating:**
```rust
let todo_dir = context.sah_dir.subdir("todo");
// Just a path, directory might not exist
```

## Benefits

### 1. Single Source of Truth
- Directory structure defined in one place
- All subdirectory paths computed from root
- Easy to see complete directory layout

### 2. Consistent Root Resolution
- All operations use same logic to find .swissarmyhammer
- Git-aware by default
- Explicit choice for user-home vs git-root

### 3. Testing Made Easy
```rust
#[test]
fn test_something() {
    let temp = TempDir::new().unwrap();
    let sah_dir = SwissarmyhammerDirectory::from_custom_root(temp.path())?;

    // Now all operations use the temp directory
    let todo_dir = sah_dir.ensure_subdir("todo")?;
    // Test with todo_dir...
}
```

### 4. Eliminates Duplication
- Remove `get_swissarmyhammer_dir()` from paths.rs
- Remove direct directory creation from domain crates
- One canonical pattern

### 5. Tool-Agnostic Design
- Struct doesn't know about specific tools (no todo_dir, rules_dir methods)
- Tools ask for subdirectories by name: `ensure_subdir("todo")`
- No coupling between SwissarmyhammerDirectory and tool implementations
- Can add new tools without modifying the struct

### 6. Better Error Messages
```rust
impl Display for DirectoryRootType {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        match self {
            Self::UserHome => write!(f, "user home"),
            Self::GitRoot => write!(f, "git repository root"),
            Self::Custom(path) => write!(f, "custom path: {}", path.display()),
        }
    }
}
```

Errors can say "Failed to create todo directory in git repository root" vs "Failed to create directory".

## Migration Path

### Phase 1: Create the Struct
1. Add `SwissarmyhammerDirectory` to swissarmyhammer-common
2. Implement from_git_root(), from_user_home(), from_custom_root()
3. Add subdirectory accessor methods (todo_dir, rules_dir, etc.)
4. Add tests

### Phase 2: Add to ToolContext
1. Add `sah_dir: SwissarmyhammerDirectory` field to ToolContext
2. Update ToolContext::new() to initialize it
3. Add constructor for testing with custom root

### Phase 3: Migrate Domain Crates (one at a time)
1. Update swissarmyhammer-todo to use context.sah_dir
2. Update swissarmyhammer-workflow to use context.sah_dir
3. Remove issues/memos (already planned elimination)

### Phase 4: Cleanup
1. Remove `get_swissarmyhammer_dir()` from paths.rs
2. Update all direct .swissarmyhammer creation to use the struct
3. Update documentation

## Standard Directory Structure

Once we have SwissarmyhammerDirectory, we can document the canonical structure:

```
.swissarmyhammer/
â”œâ”€â”€ rules/              # Project-specific rules (git-tracked)
â”‚   â”œâ”€â”€ code-quality/
â”‚   â”œâ”€â”€ security/
â”‚   â””â”€â”€ _partials/
â”œâ”€â”€ todo/               # Ephemeral todos (gitignored)
â”‚   â””â”€â”€ todo.yaml
â”œâ”€â”€ tmp/                # Temporary files (gitignored)
â”œâ”€â”€ workflow-runs/      # Workflow execution history (gitignored)
â””â”€â”€ transcripts/        # Agent transcripts (gitignored)
```

**Eliminated after migration:**
- ~~issues/~~ (to be removed)
- ~~memos/~~ (to be removed)

## Open Questions

1. Should ToolContext always use GitRoot, or should it be configurable? Should be able to pass ot a new ToolContext to allow testing.
2. Should we pre-create all subdirectories, or create on demand? âœ… **On demand** via ensure_subdir()
3. Should the struct be Clone-able or should we use Arc<SwissarmyhammerDirectory>?
4. Should subdirectory accessors create the directories or just return paths? âœ… **Both** - subdir() returns path, ensure_subdir() creates
5. âœ… **No** hard-coded methods per tool - use generic subdir(name) / ensure_subdir(name)

## Current Duplicate Directory Creation Points TO REMOVE

### Domain Crates Creating .swissarmyhammer Directly

1. **swissarmyhammer-issues/src/storage.rs:91-96**
   ```rust
   pub fn default_directory_in(work_dir: &Path) -> Result<PathBuf> {
       let swissarmyhammer_dir = work_dir.join(".swissarmyhammer");
       let issues_dir = swissarmyhammer_dir.join("issues");
       fs::create_dir_all(&issues_dir).map_err(Error::Io)?;
       Ok(issues_dir)
   }
   ```
   **Remove**: Entire issues crate being eliminated anyway

2. **swissarmyhammer-issues/src/storage.rs:62-63**
   ```rust
   fs::create_dir_all(&issues_dir).map_err(Error::Io)?;
   fs::create_dir_all(&completed_dir).map_err(Error::Io)?;
   ```
   **Remove**: Entire issues crate being eliminated anyway

3. **swissarmyhammer-memoranda/src/storage.rs:47-53**
   ```rust
   let memos_dir = swissarmyhammer_common::utils::paths::get_swissarmyhammer_dir()
       .map_err(|e| ...)?
       .join("memos");
   fs::create_dir_all(&memos_dir).await?;
   ```
   **Remove**: Entire memoranda crate being eliminated anyway

4. **swissarmyhammer-workflow/src/executor/core.rs:172**
   ```rust
   if let Err(e) = std::fs::create_dir_all(".swissarmyhammer") {
   ```
   **Replace with**: Use `context.sah_dir.root()` or `ensure_subdir()`

5. **swissarmyhammer-todo/src/utils.rs:25-37** âœ… CORRECT PATTERN (but update to use struct)
   ```rust
   let swissarmyhammer_dir = get_or_create_swissarmyhammer_directory()?;
   let todo_dir = swissarmyhammer_dir.join("todo");
   fs::create_dir_all(&todo_dir)?;
   ```
   **Update to**: Use `context.sah_dir.ensure_subdir("todo")?`

### Common Utilities TO DEPRECATE/REMOVE

6. **swissarmyhammer-common/src/utils/paths.rs:9-18**
   ```rust
   pub fn get_swissarmyhammer_dir() -> Result<PathBuf, std::io::Error> {
       let current_dir = std::env::current_dir()?;
       let swissarmyhammer_dir = current_dir.join(".swissarmyhammer");
       if !swissarmyhammer_dir.exists() {
           std::fs::create_dir_all(&swissarmyhammer_dir)?;
       }
       Ok(swissarmyhammer_dir)
   }
   ```
   **Remove**: Deprecated by SwissarmyhammerDirectory
   **Note**: This is NOT Git-aware, just uses current directory

7. **swissarmyhammer-common/src/utils/directory_utils.rs:114-122**
   ```rust
   pub fn get_or_create_swissarmyhammer_directory() -> Result<PathBuf>
   ```
   **Replace with**: `SwissarmyhammerDirectory::from_git_root()`
   **Note**: This IS Git-aware (the correct pattern)

8. **swissarmyhammer-common/src/utils/directory_utils.rs:136-160**
   ```rust
   pub fn get_or_create_swissarmyhammer_directory_from(start_dir: &Path) -> Result<PathBuf>
   ```
   **Replace with**: Constructor in SwissarmyhammerDirectory

9. **swissarmyhammer-common/src/abort_utils.rs:23-38**
   ```rust
   fn get_swissarmyhammer_dir_for_path<P: AsRef<Path>>(work_dir: P) -> Result<PathBuf>
   ```
   **Update to**: Use SwissarmyhammerDirectory

### Current Callers (need updating)

**Using Git-aware version:**
- swissarmyhammer-todo/src/utils.rs:25 â†’ Update to use struct

**Using simple version:**
- swissarmyhammer-memoranda/src/storage.rs:47 â†’ Being eliminated
- swissarmyhammer-cli/src/context.rs:202 â†’ Update to use struct

**Using direct creation:**
- swissarmyhammer-workflow/src/executor/core.rs:172 â†’ Update to use struct
- swissarmyhammer-issues (multiple places) â†’ Being eliminated

## Related to Migration Plan

This aligns with eliminating issues/memos:
- Clean up directory structure at the same time
- Establish canonical pattern before adding rule_create
- Makes testing the new tools easier (custom roots for tests)
- Reduces from 3+ utility functions down to 1 struct
