# Rules Cache Force Flag Bug Analysis

**THIS IS A SCRATCH FILE GENERATED BY A ðŸ¤–**

## Date
2025-11-13

## Problem

User reports seeing "cache hit" messages but rules appear to be evaluated anyway.

## Investigation

### Cache Implementation (cache.rs)
- Cache uses SHA-256 hash of (file_content + rule_template + severity)
- Stores results in `~/.cache/swissarmyhammer/rules/{hash}.cache`
- `get()` method returns `Some(CachedResult)` on hit, `None` on miss
- Implementation looks correct

### Cache Usage in check_file (checker.rs:307-336)
```rust
// Check cache before proceeding with LLM evaluation
if let Some(cached_result) = self.cache.get(&cache_key)? {
    tracing::debug!(
        "Cache hit for {} against rule {} - skipping LLM call",
        target_path.display(),
        rule.name
    );

    // Return cached result
    match cached_result {
        CachedResult::Pass => {
            return Ok(None);  // Early return - NO LLM call
        }
        CachedResult::Violation { violation } => {
            return Ok(Some(violation));  // Early return - NO LLM call
        }
    }
}
```

**This looks correct** - cache hits return early before LLM execution at line 404-408.

### The Bug: Force Flag Is Ignored!

**RuleCheckRequest has a `force` field:**
```rust
pub struct RuleCheckRequest {
    // ... other fields ...
    /// Force re-evaluation, bypassing cache
    pub force: bool,
    // ...
}
```

**But check_file() doesn't receive or check it!**

The `check_file()` signature is:
```rust
pub async fn check_file(
    &self,
    rule: &Rule,
    target_path: &Path,
) -> Result<Option<RuleViolation>>
```

It has NO force parameter, and doesn't have access to the RuleCheckRequest.

### The Flow

1. `check_streaming()` receives `RuleCheckRequest` with `force: bool`
2. `check_streaming()` calls `check_file()` for each file/rule pair
3. `check_file()` **ALWAYS checks cache**, regardless of force flag
4. **The force flag is completely ignored**

### Why User Sees Cache Hits But Still Sees Evaluation

**Hypothesis**: The user might be seeing:
- "Cache hit" log messages (from cache.rs:217)
- AND
- LLM evaluation happening

This shouldn't be possible with the current code structure... UNLESS:

**Possibility 1**: Multiple runs
- First run: cache miss â†’ evaluates â†’ stores
- Second run: cache hit â†’ returns early (no evaluation)
- User seeing logs from both runs?

**Possibility 2**: Different files with same hash (unlikely)

**Possibility 3**: Cache directory permissions issue
- cache.get() fails silently and returns None?
- No - it would return Err, not None

**Possibility 4**: The log messages are confusing
- User seeing "Cache hit" from cache.rs:217
- But that's BEFORE the early return
- The log says "skipping LLM call"
- Is the LLM call actually being skipped?

## To Verify

Need to check:
1. Are there multiple log messages showing evaluation for the SAME file/rule pair?
2. Is the force flag being set to true somewhere (bypassing intended cache)?
3. Is there error handling that catches cache errors and continues?

## Bugs Found

### Bug 1: Force Flag Not Implemented
**Location**: check_file() method
**Issue**: `force` parameter exists in Request but is never used
**Fix**: Pass force flag to check_file(), skip cache check if force=true

```rust
// Proposed fix in check_file():
pub async fn check_file(
    &self,
    rule: &Rule,
    target_path: &Path,
    force: bool,  // ADD THIS
) -> Result<Option<RuleViolation>> {
    // ... read file, check ignore ...

    // Calculate cache key
    let cache_key = RuleCache::calculate_cache_key(...);

    // Check cache ONLY if not forced
    if !force {  // ADD THIS CHECK
        if let Some(cached_result) = self.cache.get(&cache_key)? {
            // ... return cached result ...
        }
    }

    // ... proceed with LLM evaluation ...
}
```

### Bug 2: Force Flag Lost in Streaming
**Location**: check_streaming() method line ~620
**Issue**: When calling check_file(), force flag is not passed

```rust
// Current (line 624):
async move { checker.check_file(&rule, &target) .await }

// Proposed:
async move { checker.check_file(&rule, &target, force).await }
```

But this requires capturing `force` from the request.

## Recommendation

1. Add `force: bool` parameter to `check_file()`
2. Check force flag before accessing cache
3. Update all callers of check_file() to pass force
4. Add test for force flag behavior

## User's Actual Issue - RESOLVED

**User feedback**: "it was just tracing at debug"

The cache IS working correctly. Cache hits skip LLM evaluation as intended. The confusion was from debug log messages that appear before the early return:

```rust
if let Some(cached_result) = self.cache.get(&cache_key)? {
    tracing::debug!("Cache hit for {} against rule {} - skipping LLM call", ...);
    // Early return here - LLM is NOT called
    return Ok(...);
}
```

When debug logging is enabled, user sees "Cache hit" and "skipping LLM call", but because it's a debug message it looked like something was still happening. The cache is working correctly.

## Real Bug Still Exists

The `force` parameter bug is real - if someone tries to use `force: true`, it won't work because the flag is never checked.
