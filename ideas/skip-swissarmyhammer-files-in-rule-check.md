# Skip .swissarmyhammer Files in Rule Checker

**THIS IS A SCRATCH FILE GENERATED BY A ðŸ¤–**

## Date
2025-11-13

## Problem

Rule checker needs to skip files in `.swissarmyhammer/` directory, but should do this intelligently using the SwissarmyhammerDirectory from context, not by doing string matching.

## Current Behavior

**File collection**: `swissarmyhammer-rules/src/checker.rs:599-605`

```rust
// Phase 4: Expand glob patterns to get target files
let config = GlobExpansionConfig::default();
let mut target_files = expand_glob_patterns(&request.patterns, &config)?;

// Sort target files for consistent ordering
target_files.sort();
```

**Glob expansion**: `swissarmyhammer-common/src/glob_utils.rs:58-61`

Uses `WalkBuilder` with `respect_gitignore: true` by default:
```rust
let walker = WalkBuilder::new(&path)
    .git_ignore(config.respect_gitignore)  // defaults to true
    .git_global(config.respect_gitignore)
    .git_exclude(config.respect_gitignore)
    .ignore(config.respect_gitignore)
    // ...
```

**Current reliance**: .gitignore to exclude .swissarmyhammer files

## Issues with Current Approach

### 1. Depends on .gitignore Configuration
- Only works if .swissarmyhammer is in .gitignore
- User might have specific subdirectories they DO want checked
- No explicit control over what's excluded

### 2. Not Context-Aware
- Doesn't use the SwissarmyhammerDirectory from context
- Can't distinguish between:
  - `.swissarmyhammer/` (should skip)
  - `node_modules/.swissarmyhammer/` (maybe should skip?)
  - `vendor/.swissarmyhammer/` (maybe should skip?)

### 3. String-Based Would Be Fragile
```rust
// WRONG approach (dumb string matching):
target_files.retain(|path| {
    !path.to_string_lossy().contains(".swissarmyhammer")
});
```

This would incorrectly skip:
- `/projects/.swissarmyhammer-backup/src/main.rs`
- `/code/my-.swissarmyhammer-test/lib.rs`
- Any path with ".swissarmyhammer" substring

### 4. No Flexibility
- Can't check specific files in .swissarmyhammer if needed
- All-or-nothing based on gitignore

## Proposed Solution: Context-Aware Filtering

### Step 1: Add to SwissarmyhammerDirectory

```rust
impl SwissarmyhammerDirectory {
    /// Check if a path is within the .swissarmyhammer directory
    pub fn contains_path(&self, path: &Path) -> bool {
        path.starts_with(&self.root)
    }

    /// Get the canonical path for comparison
    pub fn canonical_root(&self) -> Result<PathBuf> {
        self.root.canonicalize()
    }
}
```

### Step 2: Pass Context to expand_glob_patterns

**Current signature:**
```rust
pub fn expand_glob_patterns(
    patterns: &[String],
    config: &GlobExpansionConfig,
) -> Result<Vec<PathBuf>>
```

**New signature:**
```rust
pub fn expand_glob_patterns(
    patterns: &[String],
    config: &GlobExpansionConfig,
    exclude_paths: Option<&[PathBuf]>,  // Paths to explicitly exclude
) -> Result<Vec<PathBuf>>
```

### Step 3: Update Checker to Pass Exclusions

```rust
// In checker.rs:
pub async fn check_streaming(
    &self,
    request: RuleCheckRequest,
    sah_dir: &SwissarmyhammerDirectory,  // Add this parameter
) -> Result<impl Stream<Item = Result<RuleViolation>>> {
    // ...

    // Phase 4: Expand glob patterns to get target files
    let config = GlobExpansionConfig::default();
    let exclude_paths = vec![sah_dir.root().to_path_buf()];
    let mut target_files = expand_glob_patterns(
        &request.patterns,
        &config,
        Some(&exclude_paths)
    )?;

    // ...
}
```

### Step 4: Filter in expand_glob_patterns

```rust
pub fn expand_glob_patterns(
    patterns: &[String],
    config: &GlobExpansionConfig,
    exclude_paths: Option<&[PathBuf]>,
) -> Result<Vec<PathBuf>> {
    let mut target_files = Vec::new();

    // ... existing glob expansion logic ...

    // Filter out excluded paths using proper path comparison
    if let Some(exclusions) = exclude_paths {
        target_files.retain(|file_path| {
            // Canonicalize both paths for comparison
            if let (Ok(canonical_file), Ok(canonical_exclusions)) = (
                file_path.canonicalize(),
                exclusions.iter().map(|p| p.canonicalize()).collect::<Result<Vec<_>, _>>()
            ) {
                // Check if file is under any excluded path
                !canonical_exclusions.iter().any(|excluded| {
                    canonical_file.starts_with(excluded)
                })
            } else {
                // If canonicalization fails, keep the file (err on side of checking)
                true
            }
        });
    }

    Ok(target_files)
}
```

## Benefits

### 1. Context-Aware
- Uses actual SwissarmyhammerDirectory path from context
- Knows exactly which directory to exclude

### 2. Proper Path Comparison
- Uses `starts_with()` on canonicalized paths
- Handles symlinks correctly
- No string matching fragility

### 3. Flexible
- Can exclude multiple paths if needed
- Can be extended for other exclusions
- Independent of .gitignore

### 4. Explicit
- Clear intent: "skip the .swissarmyhammer directory"
- Not relying on implicit gitignore behavior
- Self-documenting code

## Alternative: Add to GlobExpansionConfig

Instead of a separate parameter, add to the config:

```rust
pub struct GlobExpansionConfig {
    pub respect_gitignore: bool,
    pub case_sensitive: bool,
    pub include_hidden: bool,
    pub max_files: usize,
    pub sort_by_mtime: bool,
    pub exclude_paths: Vec<PathBuf>,  // NEW: Explicit exclusions
}
```

Then:
```rust
let mut config = GlobExpansionConfig::default();
config.exclude_paths = vec![sah_dir.root().to_path_buf()];
let target_files = expand_glob_patterns(&request.patterns, &config)?;
```

## Current .gitignore Entries

From grep results, .gitignore has:
```
# Line 1: Comment saying issues is real and should NOT be ignored
# Line 63-67: Some test-specific .swissarmyhammer entries
swissarmyhammer/.swissarmyhammer
swissarmyhammer-agent-executor/.swissarmyhammer
swissarmyhammer-cli/.swissarmyhammer
swissarmyhammer-workflow/.swissarmyhammer
swissarmyhammer-tools/.swissarmyhammer
```

But NOT a global `.swissarmyhammer/` entry at the root!

So currently, .swissarmyhammer files at the project root ARE being checked by rules.

## Recommendation

Implement context-aware exclusion:
1. Add `exclude_paths` to `GlobExpansionConfig`
2. Update `expand_glob_patterns` to filter based on canonicalized path prefixes
3. Update `checker.rs` to pass `sah_dir.root()` as an exclusion
4. Add tests verifying .swissarmyhammer files are skipped

This requires SwissarmyhammerDirectory to be on the context first.

## Dependencies

- Blocked by: SwissarmyhammerDirectory struct implementation
- Blocked by: SwissarmyhammerDirectory on ToolContext
- Can implement: Once context has sah_dir field
