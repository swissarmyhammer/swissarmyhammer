# Cache Clearing Analysis

**THIS IS A SCRATCH FILE GENERATED BY A ü§ñ**

## Date
2025-11-13

## User Observation

User sees cache entries with timestamps, but suspects cache is being cleared.

## Cache Storage

**Location**: `~/.cache/swissarmyhammer/rules/`
- User-level cache (not project-level)
- Shared across ALL SwissArmyHammer projects
- Persists between runs

**Format**: `{sha256-hash}.cache` files containing JSON

## Where Cache Gets Cleared

### 1. CLI Command: `sah rule cache clear`
**File**: `swissarmyhammer-cli/src/commands/rule/cache.rs:19-34`

```rust
async fn clear_cache() -> CliResult<()> {
    let cache = RuleCache::new()?;
    let count = cache.clear()?;

    if count == 0 {
        println!("Cache is already empty");
    } else {
        println!("Cleared {} cache entries", count);
    }
    Ok(())
}
```

**When called**: User explicitly runs `sah rule cache clear`

### 2. Unit Tests
**File**: `swissarmyhammer-cli/src/commands/rule/cache.rs:74-95`

```rust
#[tokio::test]
async fn test_clear_cache_with_entries() {
    // Add cache entries
    let cache = RuleCache::new().unwrap();
    let key = RuleCache::calculate_cache_key(...);
    cache.store(&key, &CachedResult::Pass).unwrap();

    // Clear the cache
    let command = CacheCommand { action: CacheAction::Clear };
    execute_cache_command(command, &context).await;

    // Verify cache is empty
    assert!(cache.get(&key).unwrap().is_none());
}
```

**PROBLEM**: This test uses THE SAME CACHE DIRECTORY as production!

`RuleCache::new()` always returns `~/.cache/swissarmyhammer/rules/` - there's no test override.

### 3. Review Workflow
**File**: `builtin/workflows/review.md`

The review workflow does NOT clear cache:
- Calls `are_rules_passing` prompt
- Which calls `rules_check` with `changed: true`
- No cache clearing step

## The Bug: Tests Clear Production Cache

**Root cause**: Tests use the same cache directory as production.

When you run:
```bash
cargo test test_clear_cache_with_entries
```

It CLEARS your production cache at `~/.cache/swissarmyhammer/rules/`!

### Evidence

From cache.rs:128-140:
```rust
pub fn new() -> Result<Self> {
    let cache_dir = Self::get_cache_dir()?;  // Always ~/.cache/swissarmyhammer/rules/

    if !cache_dir.exists() {
        fs::create_dir_all(&cache_dir)?;
    }

    Ok(Self { cache_dir })
}
```

No environment variable override, no test-specific directory.

Compare to TodoStorage which has:
```rust
// Check for environment variable override (useful for testing)
if let Ok(override_dir) = std::env::var("SWISSARMYHAMMER_TODO_DIR") {
    let todo_dir = PathBuf::from(override_dir);
    fs::create_dir_all(&todo_dir)?;
    return Ok(todo_dir);
}
```

RuleCache has NO such override mechanism.

## Solutions

### Option A: Add Test Override to RuleCache

```rust
impl RuleCache {
    pub fn new() -> Result<Self> {
        let cache_dir = if let Ok(test_dir) = std::env::var("SWISSARMYHAMMER_CACHE_DIR") {
            PathBuf::from(test_dir)
        } else {
            Self::get_cache_dir()?
        };

        // ... rest of implementation
    }
}
```

Then in tests:
```rust
#[tokio::test]
async fn test_clear_cache_with_entries() {
    let temp = TempDir::new().unwrap();
    std::env::set_var("SWISSARMYHAMMER_CACHE_DIR", temp.path());

    // Now cache operations use temp directory
    // ... test code ...

    std::env::remove_var("SWISSARMYHAMMER_CACHE_DIR");
}
```

### Option B: Add new_with_dir() Constructor

```rust
impl RuleCache {
    pub fn new() -> Result<Self> {
        let cache_dir = Self::get_cache_dir()?;
        Self::new_with_dir(cache_dir)
    }

    pub fn new_with_dir(cache_dir: PathBuf) -> Result<Self> {
        if !cache_dir.exists() {
            fs::create_dir_all(&cache_dir)?;
        }
        Ok(Self { cache_dir })
    }
}
```

Then tests use:
```rust
let temp = TempDir::new().unwrap();
let cache = RuleCache::new_with_dir(temp.path().to_path_buf())?;
```

### Option C: SwissarmyhammerDirectory Integration

Once we have SwissarmyhammerDirectory:
```rust
impl RuleCache {
    pub fn new_from_sah_dir(sah_dir: &SwissarmyhammerDirectory) -> Result<Self> {
        let cache_dir = sah_dir.ensure_subdir("cache/rules")?;
        Self::new_with_dir(cache_dir)
    }
}
```

This would move cache into `.swissarmyhammer/cache/rules/` (project-level) instead of `~/.cache/swissarmyhammer/rules/` (user-level).

## Recommendations

### Immediate Fix
Use Option A or B to prevent tests from clearing production cache.

### Long-term Question
**Should the cache be user-level or project-level?**

**User-level** (`~/.cache/swissarmyhammer/rules/`):
- ‚úÖ Shared across projects (same file + rule = cached)
- ‚úÖ Standard platform cache location
- ‚ùå Not version controlled
- ‚ùå Different team members don't share cache
- ‚ùå CI/CD has to rebuild cache every time

**Project-level** (`.swissarmyhammer/cache/rules/`):
- ‚úÖ Can be committed to git (shared cache across team)
- ‚úÖ CI/CD can cache between runs
- ‚úÖ Isolated per project
- ‚ùå Same file checked in different projects = separate cache entries
- ‚ùå Takes up space in git repo

**Current**: User-level (standard for caches)
**Typical pattern**: User-level for personal caches, but tests should use temp directories

## User's Issue Confirmed

If you run `cargo test` or `cargo nextest run`, any test that calls `cache.clear()` will clear your production cache at `~/.cache/swissarmyhammer/rules/`.

This explains why cache timestamps seem fresh - tests are clearing it!
