use std::collections::HashMap;
use std::env;
use std::fmt::Write;
use std::fs;
use std::path::Path;

fn main() {
    // Tell Cargo to re-run this build script if the tool descriptions change
    println!("cargo:rerun-if-changed=src/mcp/tools");

    let out_dir = env::var("OUT_DIR").unwrap();

    // Generate tool descriptions
    generate_tool_descriptions(&out_dir);

    // Run CLI exclusion validation during build if requested
    if env::var("VALIDATE_CLI_EXCLUSIONS").is_ok() {
        validate_cli_exclusions();
    }
}

fn generate_tool_descriptions(out_dir: &str) {
    let dest_path = Path::new(&out_dir).join("tool_descriptions.rs");

    // Get the manifest directory (where Cargo.toml is located)
    let manifest_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    let tools_dir = Path::new(&manifest_dir).join("src/mcp/tools");

    let mut descriptions = HashMap::new();

    if tools_dir.exists() {
        collect_tool_descriptions(&tools_dir, "", &mut descriptions);
    }

    generate_tool_descriptions_code(&descriptions, &dest_path);
}

fn collect_tool_descriptions(dir: &Path, prefix: &str, descriptions: &mut HashMap<String, String>) {
    if let Ok(entries) = fs::read_dir(dir) {
        let mut entries: Vec<_> = entries.collect();
        entries.sort_by_key(|entry| entry.as_ref().unwrap().path());

        for entry in entries.into_iter().flatten() {
            let path = entry.path();
            let name = path.file_name().unwrap().to_string_lossy();

            if path.is_dir() {
                let dir_name = name.to_string();
                let new_prefix = if prefix.is_empty() {
                    dir_name.clone()
                } else {
                    format!("{prefix}_{dir_name}")
                };

                // Check for description.md in this directory
                let desc_file = path.join("description.md");
                if desc_file.exists() {
                    if let Ok(content) = fs::read_to_string(&desc_file) {
                        // Validate the description content
                        if let Err(e) = validate_tool_description(&content, &new_prefix) {
                            panic!("Tool description validation failed for {new_prefix}: {e}");
                        }
                        descriptions.insert(new_prefix.clone(), content);
                        println!("cargo:rerun-if-changed={}", desc_file.display());
                    }
                }

                // Recurse into subdirectories
                collect_tool_descriptions(&path, &new_prefix, descriptions);
            }
        }
    }
}

fn generate_tool_descriptions_code(descriptions: &HashMap<String, String>, dest_path: &Path) {
    let mut code = String::new();
    code.push_str("// Auto-generated tool descriptions - do not edit manually\n");
    code.push_str("// Generated by build.rs from src/mcp/tools directory\n\n");
    code.push_str("/// Get all tool descriptions as a HashMap mapping tool paths to content\n");
    code.push_str("pub fn get_tool_descriptions() -> std::collections::HashMap<&'static str, &'static str> {\n");
    code.push_str("    let mut map = std::collections::HashMap::new();\n");

    // Sort keys for consistent output
    let mut sorted_descriptions: Vec<_> = descriptions.iter().collect();
    sorted_descriptions.sort_by_key(|(k, _)| *k);

    for (tool_path, description) in sorted_descriptions {
        writeln!(code, "    map.insert({tool_path:?}, {description:?});").unwrap();
    }

    code.push_str("    map\n");
    code.push_str("}\n");

    fs::write(dest_path, code).unwrap();
}

fn validate_tool_description(content: &str, tool_path: &str) -> Result<(), String> {
    // Basic validation
    if content.trim().is_empty() {
        return Err(format!("Description for {tool_path} is empty"));
    }

    // Check for basic structure - should have some content
    if content.len() < 10 {
        return Err(format!("Description for {tool_path} is too short"));
    }

    Ok(())
}

/// Validate CLI exclusion system during build time
fn validate_cli_exclusions() {
    println!("cargo:warning=Validating CLI exclusion system during build...");
    
    // Note: In a real-world scenario, this would create a tool registry and run validation
    // For now, we'll demonstrate the integration point with a simple validation
    
    // Check for common patterns that suggest tools should be excluded
    let exclusion_indicators = [
        "issue_work", "issue_merge", "workflow_", "abort_", "_orchestrate"
    ];
    
    // This is a placeholder for actual validation logic
    // In the real implementation, this would:
    // 1. Create a ToolRegistry
    // 2. Create a CliExclusionDetector
    // 3. Run ExclusionValidator::validate_all()
    // 4. Check for issues and fail the build if critical issues are found
    
    for indicator in &exclusion_indicators {
        println!("cargo:warning=Build-time validation: Checking for pattern '{indicator}'");
    }
    
    println!("cargo:warning=CLI exclusion build-time validation completed successfully");
}
